// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/zhixunjie/im-fun/internal/logic/data/ent/generate/model"
)

func newChatGroupMessage(db *gorm.DB, opts ...gen.DOOption) chatGroupMessage {
	_chatGroupMessage := chatGroupMessage{}

	_chatGroupMessage.chatGroupMessageDo.UseDB(db, opts...)
	_chatGroupMessage.chatGroupMessageDo.UseModel(&model.ChatGroupMessage{})

	tableName := _chatGroupMessage.chatGroupMessageDo.TableName()
	_chatGroupMessage.ALL = field.NewAsterisk(tableName)
	_chatGroupMessage.ID = field.NewUint64(tableName, "id")
	_chatGroupMessage.MsgID = field.NewUint64(tableName, "msg_id")
	_chatGroupMessage.SeqID = field.NewUint64(tableName, "seq_id")
	_chatGroupMessage.MsgType = field.NewUint32(tableName, "msg_type")
	_chatGroupMessage.Content = field.NewString(tableName, "content")
	_chatGroupMessage.SessionID = field.NewString(tableName, "session_id")
	_chatGroupMessage.SenderID = field.NewUint64(tableName, "sender_id")
	_chatGroupMessage.SenderType = field.NewUint32(tableName, "sender_type")
	_chatGroupMessage.VersionID = field.NewUint64(tableName, "version_id")
	_chatGroupMessage.SortKey = field.NewUint64(tableName, "sort_key")
	_chatGroupMessage.Status = field.NewUint32(tableName, "status")
	_chatGroupMessage.HasRead = field.NewUint32(tableName, "has_read")
	_chatGroupMessage.RefUids = field.NewString(tableName, "ref_uids")
	_chatGroupMessage.CreatedAt = field.NewTime(tableName, "created_at")
	_chatGroupMessage.UpdatedAt = field.NewTime(tableName, "updated_at")

	_chatGroupMessage.fillFieldMap()

	return _chatGroupMessage
}

// chatGroupMessage 群组消息表（一条私信只有一行记录），减少messge表的空间
type chatGroupMessage struct {
	chatGroupMessageDo

	ALL        field.Asterisk
	ID         field.Uint64 // 自增id
	MsgID      field.Uint64 // 消息唯一id（服务端生成）
	SeqID      field.Uint64 // 消息唯一id（客户端生成）
	MsgType    field.Uint32 // 消息类型
	Content    field.String // 消息内容，json格式
	SessionID  field.String // 会话id
	SenderID   field.Uint64 // 消息发送者id
	SenderType field.Uint32 // 消息发送者的用户类型
	VersionID  field.Uint64 // 版本id（用于拉取消息）
	SortKey    field.Uint64 // 消息展示顺序（按顺序展示消息）
	Status     field.Uint32 // 消息状态
	HasRead    field.Uint32 // 接收方是否已读，0：未读，1：已读
	RefUids    field.String // @我的用户（[1001,1002]）
	CreatedAt  field.Time   // 创建时间
	UpdatedAt  field.Time   // 更新时间

	fieldMap map[string]field.Expr
}

func (c chatGroupMessage) Table(newTableName string) *chatGroupMessage {
	c.chatGroupMessageDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c chatGroupMessage) As(alias string) *chatGroupMessage {
	c.chatGroupMessageDo.DO = *(c.chatGroupMessageDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *chatGroupMessage) updateTableName(table string) *chatGroupMessage {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint64(table, "id")
	c.MsgID = field.NewUint64(table, "msg_id")
	c.SeqID = field.NewUint64(table, "seq_id")
	c.MsgType = field.NewUint32(table, "msg_type")
	c.Content = field.NewString(table, "content")
	c.SessionID = field.NewString(table, "session_id")
	c.SenderID = field.NewUint64(table, "sender_id")
	c.SenderType = field.NewUint32(table, "sender_type")
	c.VersionID = field.NewUint64(table, "version_id")
	c.SortKey = field.NewUint64(table, "sort_key")
	c.Status = field.NewUint32(table, "status")
	c.HasRead = field.NewUint32(table, "has_read")
	c.RefUids = field.NewString(table, "ref_uids")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")

	c.fillFieldMap()

	return c
}

func (c *chatGroupMessage) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *chatGroupMessage) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 15)
	c.fieldMap["id"] = c.ID
	c.fieldMap["msg_id"] = c.MsgID
	c.fieldMap["seq_id"] = c.SeqID
	c.fieldMap["msg_type"] = c.MsgType
	c.fieldMap["content"] = c.Content
	c.fieldMap["session_id"] = c.SessionID
	c.fieldMap["sender_id"] = c.SenderID
	c.fieldMap["sender_type"] = c.SenderType
	c.fieldMap["version_id"] = c.VersionID
	c.fieldMap["sort_key"] = c.SortKey
	c.fieldMap["status"] = c.Status
	c.fieldMap["has_read"] = c.HasRead
	c.fieldMap["ref_uids"] = c.RefUids
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
}

func (c chatGroupMessage) clone(db *gorm.DB) chatGroupMessage {
	c.chatGroupMessageDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c chatGroupMessage) replaceDB(db *gorm.DB) chatGroupMessage {
	c.chatGroupMessageDo.ReplaceDB(db)
	return c
}

type chatGroupMessageDo struct{ gen.DO }

type IChatGroupMessageDo interface {
	gen.SubQuery
	Debug() IChatGroupMessageDo
	WithContext(ctx context.Context) IChatGroupMessageDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IChatGroupMessageDo
	WriteDB() IChatGroupMessageDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IChatGroupMessageDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IChatGroupMessageDo
	Not(conds ...gen.Condition) IChatGroupMessageDo
	Or(conds ...gen.Condition) IChatGroupMessageDo
	Select(conds ...field.Expr) IChatGroupMessageDo
	Where(conds ...gen.Condition) IChatGroupMessageDo
	Order(conds ...field.Expr) IChatGroupMessageDo
	Distinct(cols ...field.Expr) IChatGroupMessageDo
	Omit(cols ...field.Expr) IChatGroupMessageDo
	Join(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo
	RightJoin(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo
	Group(cols ...field.Expr) IChatGroupMessageDo
	Having(conds ...gen.Condition) IChatGroupMessageDo
	Limit(limit int) IChatGroupMessageDo
	Offset(offset int) IChatGroupMessageDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IChatGroupMessageDo
	Unscoped() IChatGroupMessageDo
	Create(values ...*model.ChatGroupMessage) error
	CreateInBatches(values []*model.ChatGroupMessage, batchSize int) error
	Save(values ...*model.ChatGroupMessage) error
	First() (*model.ChatGroupMessage, error)
	Take() (*model.ChatGroupMessage, error)
	Last() (*model.ChatGroupMessage, error)
	Find() ([]*model.ChatGroupMessage, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ChatGroupMessage, err error)
	FindInBatches(result *[]*model.ChatGroupMessage, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ChatGroupMessage) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IChatGroupMessageDo
	Assign(attrs ...field.AssignExpr) IChatGroupMessageDo
	Joins(fields ...field.RelationField) IChatGroupMessageDo
	Preload(fields ...field.RelationField) IChatGroupMessageDo
	FirstOrInit() (*model.ChatGroupMessage, error)
	FirstOrCreate() (*model.ChatGroupMessage, error)
	FindByPage(offset int, limit int) (result []*model.ChatGroupMessage, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IChatGroupMessageDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	GetByID(id int64) (result *model.ChatGroupMessage, err error)
}

// GetByID SELECT * FROM @@table WHERE id=@id
func (c chatGroupMessageDo) GetByID(id int64) (result *model.ChatGroupMessage, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM chat_group_message WHERE id=? ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (c chatGroupMessageDo) Debug() IChatGroupMessageDo {
	return c.withDO(c.DO.Debug())
}

func (c chatGroupMessageDo) WithContext(ctx context.Context) IChatGroupMessageDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c chatGroupMessageDo) ReadDB() IChatGroupMessageDo {
	return c.Clauses(dbresolver.Read)
}

func (c chatGroupMessageDo) WriteDB() IChatGroupMessageDo {
	return c.Clauses(dbresolver.Write)
}

func (c chatGroupMessageDo) Session(config *gorm.Session) IChatGroupMessageDo {
	return c.withDO(c.DO.Session(config))
}

func (c chatGroupMessageDo) Clauses(conds ...clause.Expression) IChatGroupMessageDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c chatGroupMessageDo) Returning(value interface{}, columns ...string) IChatGroupMessageDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c chatGroupMessageDo) Not(conds ...gen.Condition) IChatGroupMessageDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c chatGroupMessageDo) Or(conds ...gen.Condition) IChatGroupMessageDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c chatGroupMessageDo) Select(conds ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c chatGroupMessageDo) Where(conds ...gen.Condition) IChatGroupMessageDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c chatGroupMessageDo) Order(conds ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c chatGroupMessageDo) Distinct(cols ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c chatGroupMessageDo) Omit(cols ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c chatGroupMessageDo) Join(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c chatGroupMessageDo) LeftJoin(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c chatGroupMessageDo) RightJoin(table schema.Tabler, on ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c chatGroupMessageDo) Group(cols ...field.Expr) IChatGroupMessageDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c chatGroupMessageDo) Having(conds ...gen.Condition) IChatGroupMessageDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c chatGroupMessageDo) Limit(limit int) IChatGroupMessageDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c chatGroupMessageDo) Offset(offset int) IChatGroupMessageDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c chatGroupMessageDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IChatGroupMessageDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c chatGroupMessageDo) Unscoped() IChatGroupMessageDo {
	return c.withDO(c.DO.Unscoped())
}

func (c chatGroupMessageDo) Create(values ...*model.ChatGroupMessage) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c chatGroupMessageDo) CreateInBatches(values []*model.ChatGroupMessage, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c chatGroupMessageDo) Save(values ...*model.ChatGroupMessage) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c chatGroupMessageDo) First() (*model.ChatGroupMessage, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatGroupMessage), nil
	}
}

func (c chatGroupMessageDo) Take() (*model.ChatGroupMessage, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatGroupMessage), nil
	}
}

func (c chatGroupMessageDo) Last() (*model.ChatGroupMessage, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatGroupMessage), nil
	}
}

func (c chatGroupMessageDo) Find() ([]*model.ChatGroupMessage, error) {
	result, err := c.DO.Find()
	return result.([]*model.ChatGroupMessage), err
}

func (c chatGroupMessageDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ChatGroupMessage, err error) {
	buf := make([]*model.ChatGroupMessage, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c chatGroupMessageDo) FindInBatches(result *[]*model.ChatGroupMessage, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c chatGroupMessageDo) Attrs(attrs ...field.AssignExpr) IChatGroupMessageDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c chatGroupMessageDo) Assign(attrs ...field.AssignExpr) IChatGroupMessageDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c chatGroupMessageDo) Joins(fields ...field.RelationField) IChatGroupMessageDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c chatGroupMessageDo) Preload(fields ...field.RelationField) IChatGroupMessageDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c chatGroupMessageDo) FirstOrInit() (*model.ChatGroupMessage, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatGroupMessage), nil
	}
}

func (c chatGroupMessageDo) FirstOrCreate() (*model.ChatGroupMessage, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ChatGroupMessage), nil
	}
}

func (c chatGroupMessageDo) FindByPage(offset int, limit int) (result []*model.ChatGroupMessage, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c chatGroupMessageDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c chatGroupMessageDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c chatGroupMessageDo) Delete(models ...*model.ChatGroupMessage) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *chatGroupMessageDo) withDO(do gen.Dao) *chatGroupMessageDo {
	c.DO = *do.(*gen.DO)
	return c
}
